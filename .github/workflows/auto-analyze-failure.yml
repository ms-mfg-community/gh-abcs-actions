name: 09-2. Auto Analyze Build Failures

on:
  workflow_run:
    workflows: ["*"]
    types: [completed]

permissions:
  contents: read
  actions: write
  issues: write
  pull-requests: read
  models: read

jobs:
  analyze-failure:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'failure' && github.event.workflow_run.name != 'Auto Analyze Build Failures' }}
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Log job details
      run: |
        echo "Workflow Name: ${{ github.workflow }}"
        echo "Run ID: ${{ github.run_id }}"
        echo "Job Name: ${{ github.job }}"
        echo "Repository: ${{ github.repository }}"
        echo "Actor: ${{ github.actor }}"
        
    - uses: actions/create-github-app-token@v2
      id: app-token
      with:
        app-id: ${{ vars.CI_BOT_APP_ID }}
        private-key: ${{ secrets.CI_BOT_PRIVATE_KEY }}
        owner: ${{ github.repository_owner }}

    - name: Analyze build failure
      id: analyze
      uses: actions/ai-inference@v2
      with:
        prompt-file: '.github/prompts/failed-run-analyze.prompt.yml'
        enable-github-mcp: true
        #token: ${{ secrets.GITHUB_TOKEN }}
        token: ${{ steps.app-token.outputs.token }}
        github-mcp-token: ${{ secrets.AUTO_REMEDIATION_PAT }}
        github-mcp-toolsets: 'repos,issues,pull_requests,actions,code_security,get_job_logs,context,users'
        max-tokens: 10000
        input: |
          repo: ${{ github.event.repository.name }}
          owner: ${{ github.event.repository.owner.login }}
          workflow_run_id: ${{ github.event.workflow_run.id }}

    - name: Parse results
      id: parse
      uses: actions/github-script@v7
      env:
        RESPONSE_JSON: ${{ steps.analyze.outputs.response }}
      with:
        script: |
          const responseString = process.env.RESPONSE_JSON;
          core.info(`Raw response string: ${responseString}`)
          
          if (!responseString || responseString === '') {
            core.setFailed('No response received from analysis step')
            return
          }
          
          try {
            const responseJSON = JSON.parse(responseString)
            core.info(`Parsed analysis result: ${JSON.stringify(responseJSON, null, 2)}`)
            
            // Set individual outputs for easier access in subsequent steps
            core.setOutput('category', responseJSON.category || '')
            core.setOutput('summary', responseJSON.summary || '')
            core.setOutput('plan', responseJSON.plan || '')
            core.setOutput('transient', responseJSON.transient || 'false')
            
            // Also set the full response for backward compatibility
            core.setOutput('response', responseJSON)
          } catch (error) {
            core.setFailed(`Failed to parse JSON response: ${error.message}`)
            core.info(`Problematic response string: ${responseString}`)
          }

    - name: Log parse values
      env:
        CATEGORY: ${{ steps.parse.outputs.category }}
        SUMMARY: ${{ steps.parse.outputs.summary }}
        PLAN: ${{ steps.parse.outputs.plan }}
        TRANSIENT: ${{ steps.parse.outputs.transient }}
      run: |
        printf 'Category: %s\n' "$CATEGORY"
        printf 'Summary: %s\n' "$SUMMARY"
        printf 'Plan: %s\n' "$PLAN"
        printf 'Transient: %s\n' "$TRANSIENT"
     
    - name: Check for existing remediation issue
      if: ${{ steps.parse.outputs.transient == 'false' }}
      id: check-issue
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        WORKFLOW_NAME: ${{ github.event.workflow_run.name }}
        REPO: ${{ github.repository }}
      run: |
        # Search for existing open issues with the workflow label
        existing_issue=$(gh issue list \
          --repo "$REPO" \
          --state open \
          --label "workflow:$WORKFLOW_NAME" \
          --label "auto-remediation" \
          --json number \
          --jq '.[0].number')

        echo "existing_issue=$existing_issue" >> $GITHUB_OUTPUT

    - name: Create remediation issue
      id: create-issue
      if: ${{ steps.parse.outputs.transient == 'false' }}
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        WORKFLOW_NAME: ${{ github.event.workflow_run.name }}
        WORKFLOW_URL: ${{ github.event.workflow_run.html_url }}
        WORKFLOW_RUN_ID: ${{ github.event.workflow_run.id }}
        HEAD_BRANCH: ${{ github.event.workflow_run.head_branch }}
        HEAD_SHA: ${{ github.event.workflow_run.head_sha }}
        REPO: ${{ github.repository }}
        REPO_URL: ${{ github.event.repository.html_url }}
        CATEGORY: ${{ steps.parse.outputs.category }}
        SUMMARY: ${{ steps.parse.outputs.summary }}
        PLAN: ${{ steps.parse.outputs.plan }}
        EXISTING_ISSUE: ${{ steps.check-issue.outputs.existing_issue }}
      run: |
        # Check if we should create an issue or skip due to existing issue
        if [[ -n "$EXISTING_ISSUE" ]]; then
          echo "Skipping issue creation - existing issue #$EXISTING_ISSUE found"
          exit 0
        fi

        # Add note if this was a repeated transient failure
        repeat_note=""
        # (Optional enhancement) If you track repeated transient failures across runs,
        # you can set repeat_note here. This template keeps it empty by default.

        issue_body=$(cat << EOF
        ## Build Failure Analysis

        **Workflow:** [$WORKFLOW_NAME]($WORKFLOW_URL)
        **Run ID:** $WORKFLOW_RUN_ID
        **Category:** $CATEGORY
        **Branch:** $HEAD_BRANCH
        **Commit:** $HEAD_SHA

        $repeat_note

        ### Summary
        $SUMMARY

        ### Remediation Plan
        $PLAN

        ### Links
        - [Failed Workflow Run]($WORKFLOW_URL)
        - [Repository]($REPO_URL)

        ---
        *This issue was automatically created by the build failure analysis system.*
        EOF
        )

        # Ensure required labels exist
        echo "Creating labels if they don't exist..."

        # Create auto-remediation label
        gh label create "auto-remediation" \
          --description "Issues automatically created by build failure analysis" \
          --color "FF6B6B" \
          --repo "$REPO" || echo "Label 'auto-remediation' already exists or creation failed"

        # Create workflow-specific label
        gh label create "workflow:$WORKFLOW_NAME" \
          --description "Issues related to $WORKFLOW_NAME workflow" \
          --color "0052CC" \
          --repo "$REPO" || echo "Label 'workflow:$WORKFLOW_NAME' already exists or creation failed"

        # Create category-specific label
        gh label create "category:$CATEGORY" \
          --description "Issues categorized as $CATEGORY" \
          --color "7057ff" \
          --repo "$REPO" || echo "Label 'category:$CATEGORY' already exists or creation failed"

        # Create new issue
        echo "Creating new remediation issue"
        issue_url=$(gh issue create \
          --repo "$REPO" \
          --title "üîß Auto-Remediation: $WORKFLOW_NAME Build Failure" \
          --body "$issue_body" \
          --label "auto-remediation" \
          --label "workflow:$WORKFLOW_NAME" \
          --label "category:$CATEGORY")

        # Extract issue number from URL
        issue_number=$(echo "$issue_url" | sed 's/.*\/issues\///')
        echo "Created issue #$issue_number"
        echo "issue_number=$issue_number" >> $GITHUB_OUTPUT

    - name: Assign issue to Copilot
      if: ${{ steps.parse.outputs.transient == 'false' && steps.create-issue.outputs.issue_number != '' }}
      env:
        GH_TOKEN: ${{ secrets.AUTO_REMEDIATION_PAT }}
        CATEGORY: ${{ steps.parse.outputs.category }}
        ISSUE_NUMBER: ${{ steps.create-issue.outputs.issue_number }}
        REPO_OWNER: ${{ github.event.repository.owner.login }}
        REPO_NAME: ${{ github.event.repository.name }}
      run: |
        # Only assign to Copilot for code-related issues
        if [[ "$CATEGORY" == "code" || "$CATEGORY" == "test" || "$CATEGORY" == "config" ]]; then
          echo "Assigning issue #$ISSUE_NUMBER to Copilot for code-related failure"

          # First, check if Copilot is available in this repository
          copilot_response=$(gh api graphql -f query='query($owner: String!, $name: String!) {
            repository(owner: $owner, name: $name) {
              suggestedActors(capabilities: [CAN_BE_ASSIGNED], first: 100) {
                nodes {
                  login
                  __typename
                  ... on Bot {
                    id
                  }
                }
              }
            }
          }' -f owner="$REPO_OWNER" -f name="$REPO_NAME")
          copilot_id=$(echo "$copilot_response" | jq -r '.data.repository.suggestedActors.nodes[] | select(.login == "copilot-swe-agent") | .id')

          if [[ -n "$copilot_id" && "$copilot_id" != "null" ]]; then
            echo "Found Copilot agent ID: $copilot_id"

            # Get the issue GraphQL ID
            issue_response=$(gh api graphql -f query='query($owner: String!, $name: String!, $number: Int!) {
              repository(owner: $owner, name: $name) {
                issue(number: $number) {
                  id
                  title
                }
              }
            }' -f owner="$REPO_OWNER" -f name="$REPO_NAME" -F number="$ISSUE_NUMBER")
            issue_id=$(echo "$issue_response" | jq -r '.data.repository.issue.id')

            if [[ -n "$issue_id" && "$issue_id" != "null" ]]; then
              echo "Found issue ID: $issue_id"

              # Assign the issue to Copilot
              assign_response=$(gh api graphql -f query='mutation($assignableId: ID!, $actorIds: [ID!]!) {
                replaceActorsForAssignable(input: {assignableId: $assignableId, actorIds: $actorIds}) {
                  assignable {
                    ... on Issue {
                      id
                      title
                      assignees(first: 10) {
                        nodes {
                          login
                        }
                      }
                    }
                  }
                }
              }' -f assignableId="$issue_id" -f actorIds="[\"$copilot_id\"]")
              echo "Assignment response: $assign_response"

              # Check if assignment was successful
              assignees=$(echo "$assign_response" | jq -r '.data.replaceActorsForAssignable.assignable.assignees.nodes[].login')
              if echo "$assignees" | grep -qi "copilot"; then
                echo "‚úÖ Successfully assigned issue #$ISSUE_NUMBER to Copilot"
              else
                echo "‚ùå Failed to assign issue to Copilot"
                echo "Response: $assign_response"
              fi
            else
              echo "‚ùå Could not find issue GraphQL ID"
            fi
          else
            echo "‚ö†Ô∏è Copilot coding agent not available in this repository"
            echo "Available actors: $(echo "$copilot_response" | jq -r '.data.repository.suggestedActors.nodes[].login')"
          fi
        else
          echo "‚ÑπÔ∏è Issue category '$CATEGORY' does not require Copilot assignment"
        fi

    - name: Summary
      env:
        TRANSIENT: ${{ steps.parse.outputs.transient }}
        CATEGORY: ${{ steps.parse.outputs.category }}
        SUMMARY: ${{ steps.parse.outputs.summary }}
        ISSUE_NUMBER: ${{ steps.create-issue.outputs.issue_number }}
      run: |
        if [[ "$TRANSIENT" == "true" ]]; then
          echo "‚úÖ Transient failure detected - skipped issue creation"
        else
          echo "üîß Non-transient failure - remediation issue created"
          printf 'Category: %s\n' "$CATEGORY"
          printf 'Summary: %s\n' "$SUMMARY"
          printf 'ID: %s\n' "$ISSUE_NUMBER"
        fi
